<div id="{DIV_ID}" />

<h3 style="color: red">Metagraph explorer load error. Please try again.</h3>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>

<script>

  (({port, divId, shadowInnerHTML, abstractTypeToConcreteTypes, pluginData, abstractTypes}) => {

      if (typeof require === 'undefined') {
          setTimeout(this, 200, port, divId, shadowInnerHTML, abstractTypeToConcreteTypes, pluginData, abstractTypes);
          return;
      }

      /*******************/
      /* Misc. Utilities */
      /*******************/
      
      const sum = inputArray => inputArray.reduce((a, b) => a + b, 0);
      const mean = inputArray => sum(inputArray) / inputArray.length;

      const removeAllChildNodes = (parent) => {
	  while (parent.firstChild) {
              parent.removeChild(parent.firstChild);
	  }
      }

      const callAfterDOMUpdated = (func) => {
	  // Calls function after the DOM is updated to prevent non-deterministic results when grabbing element attributes, e.g. height, during transitions and animations
	  const intermediateFunc = () => window.requestAnimationFrame(func);
	  window.requestAnimationFrame(intermediateFunc);
      };

      const absoluteXYOffset = (element) => {
	  const rect = element.getBoundingClientRect();
	  const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
	  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
	  return [rect.left + scrollLeft, rect.top + scrollTop]
      }
      
      const objectSize = (object) => Object.keys(object).filter(key => object.hasOwnProperty(key)).length;
      
      /******************************/
      /* Shadow DOM Initializations */
      /******************************/
      
      const div = document.getElementById(divId);
      const shadow = div.attachShadow({mode: 'open'});
      shadow.innerHTML = shadowInnerHTML;
      shadow.websocket = new WebSocket(`ws://127.0.0.1:${port}/`);
      const closeWebsocketOnError = () => {
	  removeAllChildNodes(shadow);
	  shadow.innerHTML = `Websocket connection to ws://127.0.0.1:${port}/ failed.`;
      };
      shadow.websocket.onerror = closeWebsocketOnError;
      const sendShadowWebsocketRequest = (object) => {
	  if (shadow.websocket.readyState === WebSocket.CLOSED) {
	      closeWebsocketOnError();
	  } else {
	      shadow.websocket.send(JSON.stringify(object));
	  }
      };
      

      let highlightTranslationGraphPath = (data) => {};
      
      // Listen for websocket messages
      shadow.websocket.onmessage = function (event) {
	  data = JSON.parse(event.data);
	  switch (data.function) {
	  case 'list_types':
	      updateTypeExplorer(data);
              break;
	  case 'list_translators':
              updateTranslationGraph(data);
              break;
	  case 'list_algorithms':
	      updateAlgorithmExplorer(data);
	      updateAlgorithTypeSolver(data);
              break;
	  case 'list_algorithm_params':
	      updateAlgorithTypeSolverCurrentAlgorithmParameters(data);
	  case 'solve_translator':
	      if (data.input_kwargs.overall_abstract === abstractTypeDropdown.value) {
		  highlightTranslationGraphPath(data);
	      }
	      break;
	  case 'solve_algorithm':
	      updateAlgorithTypeSolverPlans(data);
	      break;
	  default:
              console.error('unsupported event', data);
	  }
      };

      const buildTreeWidget = (root, data) => {
	  for (let name in data) {
              if (data.hasOwnProperty(name)) {
		  const props = data[name];
		  const hasChildren = 'children' in props;
		  if (hasChildren) {
                      const label = document.createElement('p');
		      label.classList.add('mg-explorer-tree-widget-label');
                      label.innerHTML = name;
                      root.appendChild(label);
                      const container = document.createElement('div');
                      container.className = 'mg-explorer-tree-widget-subcontainer';
		      root.append(container);
		      label.onclick = (event) => {
			  label.classList.toggle('active');
			  container.classList.toggle('active');
		      };
		      const childrenData = props['children'];
                      buildTreeWidget(container, childrenData);
		  } else {
                      const leaf = document.createElement('p');
		      leaf.classList.add('mg-explorer-tree-widget-leaf');
                      leaf.innerHTML = name;
                      root.appendChild(leaf);
		  }
              }
	  }
      };
      
      /**********************************/
      /* Explorer Tab Selection Buttons */
      /**********************************/
      
      const metagraphActivateExplorerTab = (clickedElement, explorerTabId) => {
	  for (const navigationBarLi of shadow.querySelectorAll(`#mg-explorer-navigation-bar li`)) {
              navigationBarLi.classList.remove('active');
	  }
	  clickedElement.closest('li').classList.add('active');
	  for (const explorerTab of shadow.querySelectorAll('.mg-explorer-tab')) {
              explorerTab.classList.remove('active');
	  }
	  const currentExplorerTab = shadow.querySelector(`#${explorerTabId}`);
	  currentExplorerTab.classList.add('active');
      };
      
      shadow.querySelector('#mg-translation-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-translation-explorer');
      shadow.querySelector('#mg-type-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-type-explorer');
      shadow.querySelector('#mg-algorithm-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-algorithm-explorer');
      shadow.querySelector('#mg-algorithm-type-solver-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-algorithm-type-solver-explorer');
      shadow.querySelector('#mg-plugin-explorer-selector').onclick = (event) => metagraphActivateExplorerTab(event.target, 'mg-plugin-explorer');
      
      const metagraphCloseExplorer = () => {
	  sendShadowWebsocketRequest({function: 'close'});
	  shadow.websocket.close();
	  removeAllChildNodes(shadow);
      }
      
      shadow.querySelector('#mg-explorer-close-button').onclick = metagraphCloseExplorer;
      
      /*************************************/
      /* Translation Graph Initializations */
      /*************************************/
      
      require.config({paths: {d3: 'https://d3js.org/d3.v5.min'}});
      
      const concreteTypeToAbstractType = Object.keys(abstractTypeToConcreteTypes).reduce((accumulator, abstractType) => {
	  Object.keys(abstractTypeToConcreteTypes[abstractType].children).forEach(concreteType => {
	      accumulator[concreteType] = abstractType;
	  });
	  return accumulator;
      }, {})

      const abstractTypeDropdown = shadow.querySelector('#mg-translation-graph-abstract-type-dropdown');
      abstractTypes.forEach(abstractType => {
          const optionElement = document.createElement('option');
          optionElement.setAttribute('value', abstractType);
          optionElement.innerHTML = abstractType;
	  abstractTypeDropdown.append(optionElement);
      });

      let simulation = {stop: () => {}}
      const loadTranslationGraph = (translationGraphData) => {
	  
	  require(['d3'], (d3) => {

	      // D3 Extensions
	      d3.selection.prototype.moveToFront = function() {
		  return this.each(function() {
		      if (this.parentNode !== null) {
			  this.parentNode.appendChild(this);
		      }
		  });
	      };
	      
              // DOM Initializations
              const plotContainer = shadow.querySelector('div#mg-translation-graph-svg-container');
              const svg = d3.select(plotContainer.querySelector('svg#mg-translation-graph-svg'));
	      svg.selectAll('g').remove();
              svg
		  .attr('width', `${plotContainer.clientWidth}px`)
		  .attr('height', `${plotContainer.clientHeight}px`);
              const svgWidth = parseFloat(svg.style('width'));
              const svgHeight = parseFloat(svg.style('height'));
              const zoomGroup = svg.append('g').attr('class', `zoom-group-${plotContainer.id}`);
              const edgeGroup = zoomGroup.append('g').attr('class', `edge-group`);
              const nodeGroup = zoomGroup.append('g').attr('class', `node-group`);
	      const tooltipDiv = d3.select(plotContainer.querySelector('div#mg-translation-graph-tooltip'));

	      // Dropdown Initializations
	      const primaryConcreteTypes = Object.keys(translationGraphData.result.primary_types);
	      const secondaryConcreteTypes = Object.keys(translationGraphData.result.secondary_types);
	      const allConcreteTypes = primaryConcreteTypes.concat(secondaryConcreteTypes);
	      const startConcreteTypeDropdown = shadow.querySelector('#mg-translation-graph-start-concrete-type-dropdown');
	      removeAllChildNodes(startConcreteTypeDropdown);
	      const endConcreteTypeDropdown = shadow.querySelector('#mg-translation-graph-end-concrete-type-dropdown');
	      removeAllChildNodes(endConcreteTypeDropdown);
	      allConcreteTypes.forEach(concreteType => {
		  const startOptionElement = document.createElement('option');
		  startOptionElement.setAttribute('value', concreteType);
		  startOptionElement.innerHTML = concreteType;
		  startConcreteTypeDropdown.append(startOptionElement);
		  const endOptionElement = document.createElement('option');
		  endOptionElement.setAttribute('value', concreteType);
		  endOptionElement.innerHTML = concreteType;
		  endConcreteTypeDropdown.append(endOptionElement);
	      });
	      
              // Force Directed Graph Initializations
	      const nodeTextHorizontalOffset = 25;
	      const nodeTextBoundingBoxPadding = 5;
              const alphaDecay = 0.05;
              const velocityDecay = 0.9;
              const paddingBetweenNodes = 100;
              const initialLinkAlpha = 0.005;
              const linkAlphaDecay = 0.005;
              let linkAlpha = initialLinkAlpha;
	      simulation.stop();
              simulation = d3.forceSimulation()
		    .alphaDecay(alphaDecay)
		    .velocityDecay(velocityDecay);
              const drag = d3.drag();
              
              // Edge Visualization
              const edgeData = [];
	      for (edgeString in translationGraphData.result.primary_translators) {
		  const [src, dst] = edgeString.split(' -> ');
		  const datum = Object.assign({src, dst, translatorOrder: 'primary'}, translationGraphData.result.primary_translators[edgeString]);
		  edgeData.push(datum);
	      };
	      for (edgeString in translationGraphData.result.secondary_translators) {
		  const [src, dst] = edgeString.split(' -> ');
		  const datum = Object.assign({src, dst, translatorOrder: 'secondary'}, translationGraphData.result.secondary_translators[edgeString]);
		  edgeData.push(datum);
	      };
	      const edgeByNodes = {};
	      allConcreteTypes.forEach(concreteType => {
		  edgeByNodes[concreteType] = {};
	      });
	      edgeData.forEach(edge => {
		  const {src, dst} = edge;
		  edgeByNodes[src][dst] = edge;
	      });
	      const edgeConcreteTypesToLineId = (srcConcreteType, dstConcreteType) => {
		  return `${srcConcreteType}-${dstConcreteType}-line`; 
	      };
	      const hideToolTip = datum => {
		  tooltipDiv
		      .style('opacity', 0);
	      };
	      const showEdgeToolTip = function(datum) {
		  const [x, y] = absoluteXYOffset(shadow.querySelector(`#${d3.select(this).node().id}`));
		  tooltipDiv
		      .style('opacity', .9)
		      .html(`<div id="mg-translation-graph-tooltip-content">
<p>Translator Function Name: ${datum.name}</p>
<p>Source Type: ${datum.src}</p>
<p>Destination Type: ${datum.dst}</p>
<p>translator Order: ${datum.translatorOrder}</p>
<p>Plugin: ${datum.plugin}</p>
<p>Module: ${datum.module}</p>
</div>`)
		      .style('left', x + 10 + 'px')
		      .style('top', y + 10 + 'px');
	      }
              const edgeEnterSelection = edgeGroup
		    .selectAll('path')
		    .data(edgeData)
		    .enter()
		    .append('path')
		    .attr('class', 'mg-translation-graph-edge')
		    .attr('id', datum => edgeConcreteTypesToLineId(datum.src, datum.dst))
		    .on('mouseover', showEdgeToolTip)
		    .on('mouseout', hideToolTip)
		    .classed('mg-translation-graph-primary-edge', datum => datum.translatorOrder === 'primary')
		    .classed('mg-translation-graph-secondary-edge', datum => datum.translatorOrder === 'secondary')
		    .attr('marker-end','url(#mg-translation-graph-edge-arrowhead)');

              // Node Visualization
	      const nodeIdToProperties = {};
	      primaryConcreteTypes.forEach(concreteType => {
		  nodeIdToProperties[concreteType] = {id: concreteType, concreteTypeOrder: 'primary'};
	      });
	      secondaryConcreteTypes.forEach(concreteType => {
		  nodeIdToProperties[concreteType] = {id: concreteType, concreteTypeOrder: 'secondary'};
	      });
	      const concreteTypeNameToCircleId = concreteTypeName => `${concreteTypeName}-circle`
              const nodeData = Object.values(nodeIdToProperties);
	      const nodeDataJoin = nodeGroup
		    .selectAll('circle')
		    .data(nodeData);
	      const showNodeToolTip = function(datum) {
		  const [x, y] = absoluteXYOffset(shadow.querySelector(`#${d3.select(this).node().id}`));
		  tooltipDiv
		      .style('opacity', .9)
		      .html(`<div id="mg-translation-graph-tooltip-content">
<p>Name: ${datum.id}</p>
<p>Order: ${datum.concreteTypeOrder}</p>
</div>`)
		      .style('left', x + 10 + 'px')
		      .style('top', y + 10 + 'px');
	      };
              const nodeEnterSelection = nodeDataJoin
		    .enter()
		    .append('circle')
		    .attr('id', datum => concreteTypeNameToCircleId(datum.id))
		    .on('mouseover', showNodeToolTip)
		    .on('mouseout', hideToolTip)
		    .attr('class', 'mg-translation-graph-node')
		    .call(drag);
              const nodeForwardNeighbors = Object.keys(nodeIdToProperties).reduce((accumulator, nodeId) => {
		  accumulator[nodeId] = [];
		  return accumulator;
              }, {});
              edgeData.forEach((edge) => {
		  nodeForwardNeighbors[edge.src].push(edge.dst);
	      });
	      const concreteTypeNameToTextElementId = concreteType => `${concreteType}-text-element`;
              const nodeTextEnterSelection = nodeDataJoin
		    .enter()
		    .append('text')
		    .attr('dx', nodeTextHorizontalOffset)
		    .attr('id', datum => concreteTypeNameToTextElementId(datum.id))
		    .attr('class', datum => datum.concreteTypeOrder === 'primary' ? 'mg-translation-graph-node-text-primary' : 'mg-translation-graph-node-text-secondary')
		    .on('mouseover', showNodeToolTip)
		    .on('mouseout', hideToolTip)
                    .html(datum => datum.id);
	      const concreteTypeNameToTextElementBoundingBoxId = concreteType => `${concreteType}-text-element-bounding-box`;
              const nodeTextBoundingBoxEnterSelection = nodeDataJoin
		    .enter()
		    .append('rect')
		    .attr('id', datum => concreteTypeNameToTextElementBoundingBoxId(datum.id))
		    .attr('class', datum => datum.concreteTypeOrder === 'primary' ? 'mg-translation-graph-node-text-bounding-box-primary' : 'mg-translation-graph-node-text-bounding-box-secondary')
		    .classed('mg-translation-graph-node-text-bounding-box', true)
		    .on('mouseover', showNodeToolTip)
		    .on('mouseout', hideToolTip)
                    .html(datum => datum.id);

	      // Dropdown Functionality
	      const highlightConcreteTypeWithClass = (concreteTypeName, className) => {
		  nodeGroup.selectAll('.mg-translation-graph-node').classed(className, false);
		  const concreteTypeToHighlightSelector = `#${concreteTypeNameToCircleId(concreteTypeName)}`;
		  nodeGroup.select(concreteTypeToHighlightSelector).classed(className, true);
	      };
	      const requestTranslationPath = () => {
		  const startConcreteType = startConcreteTypeDropdown.value;
		  const startAbstractType = concreteTypeToAbstractType[startConcreteType];
		  const endConcreteType = endConcreteTypeDropdown.value;
		  const endAbstractType = concreteTypeToAbstractType[endConcreteType];;
		  kwargs = {
		      src_abstract: startAbstractType,
		      src_concrete: startConcreteType,
		      dst_abstract: endAbstractType,
		      dst_concrete: endConcreteType,
		      overall_abstract: abstractTypeDropdown.value,
		  }
		  highlightConcreteTypeWithClass(startConcreteTypeDropdown.value, 'mg-translation-graph-start-node');
		  highlightConcreteTypeWithClass(endConcreteTypeDropdown.value, 'mg-translation-graph-end-node');
		  sendShadowWebsocketRequest({function: 'solve_translator', kwargs: kwargs});
	      };
	      startConcreteTypeDropdown.onchange = (event) => {
		  requestTranslationPath();
	      };
	      endConcreteTypeDropdown.onchange = (event) => {
		  requestTranslationPath();
	      };
	      highlightTranslationGraphPath = (translationSolverData) => {
		  const result = translationSolverData.result;
		  const path = result.solution
		  edgeGroup.selectAll('.mg-translation-graph-highlighted-edge').classed('mg-translation-graph-highlighted-edge', false);
		  const displayTextDiv = shadow.querySelector('div#mg-translation-graph-path-display-text');
		  switch (result.result_type) {
		  case 'unsatisfiable':
		      displayTextDiv.innerHTML = '<p>Translation unsatisfiable.</p>'
		      break;
		  case 'null':
		      displayTextDiv.innerHTML = '<p>No translation needed.</p>'
		      break;
		  default:
		      for(let i=0; i < path.length - 1; i++) {
			  const srcConcreteType = path[i];
			  const dstConcreteType = path[i+1];
			  const edgeToHighlightSelector = `#${edgeConcreteTypesToLineId(srcConcreteType, dstConcreteType)}`;
			  edgeGroup.select(edgeToHighlightSelector).classed('mg-translation-graph-highlighted-edge', true);
		      }
		      removeAllChildNodes(displayTextDiv);
		      path.forEach((concreteType, i) => {
			  const divElement = document.createElement('div');
			  divElement.classList.add('mg-translation-graph-path-display-text-path-node');
			  if (i === 0) {
			      divElement.setAttribute('id', 'mg-translation-graph-path-display-text-path-start-node');
			  } else if (i === path.length-1) {
			      divElement.setAttribute('id', 'mg-translation-graph-path-display-text-path-end-node');
			  }
			  divElement.innerHTML = concreteType;
			  displayTextDiv.append(divElement);
			  if (i !== path.length-1) {
			      const arrowDiv = document.createElement('div');
			      arrowDiv.innerHTML = '&darr;';
			      displayTextDiv.append(arrowDiv)
			  }
		      })
		      break;
		  }
	      };
	      const filterByPluginDropdown = shadow.querySelector('#mg-translation-graph-filter-by-plugin-dropdown');
	      removeAllChildNodes(filterByPluginDropdown);
	      const pluginNames = Array.from(new Set(edgeData.map(edge => edge.plugin))).sort();
	      ['All Plugins'].concat(pluginNames).forEach(pluginName => {
	       	  const optionElement = document.createElement('option');
	       	  optionElement.setAttribute('value', pluginName);
	       	  optionElement.innerHTML = pluginName;
	       	  filterByPluginDropdown.append(optionElement);
	      });
	      const filterByPluginName = (pluginName) => {
		  edgeGroup
		      .selectAll('.mg-translation-graph-edge')
		      .classed('mg-translation-graph-hidden-edge', datum => pluginName !== 'All Plugins' && datum.plugin !== pluginName);
	      };
	      filterByPluginDropdown.onchange = (event) => {
		  const pluginName = event.target.value;
		  filterByPluginName(pluginName);
	      }
	      const hideTranslationPaths = () => {
		  shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button').classList.remove('active');
		  shadow.querySelector('#mg-translation-graph-translation-path-solver-menu').classList.remove('active');
		  shadow.querySelector('#mg-translation-graph-path-solver-cell').classList.remove('active');
		  edgeGroup.selectAll('.mg-translation-graph-highlighted-edge').classed('mg-translation-graph-highlighted-edge', false);
		  nodeGroup.selectAll('.mg-translation-graph-node')
		      .classed('mg-translation-graph-start-node', false)
		      .classed('mg-translation-graph-end-node', false);
	      };
	      const showTranslationPaths = () => {
		  shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button').classList.add('active');
	       	  shadow.querySelector('#mg-translation-graph-translation-path-solver-menu').classList.add('active');
	       	  shadow.querySelector('#mg-translation-graph-path-solver-cell').classList.add('active');
		  requestTranslationPath(); // TODO slow since sends another request with no path change
	      };
	      const deactivateFilterByPluginFilters = () => {
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button').classList.remove('active');
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-menu').classList.remove('active');
		  filterByPluginName('All Plugins');
	      };
	      const activateFilterByPluginFilters = () => {
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button').classList.add('active');
		  shadow.querySelector('#mg-translation-graph-filter-by-plugin-menu').classList.add('active');
		  filterByPluginName(filterByPluginDropdown.value);
	      };
	      const filterByPluginToggler = shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button');
	      filterByPluginToggler.onclick = (event) => {
	       	  hideTranslationPaths();
		  if (shadow.querySelector('#mg-translation-graph-filter-by-plugin-toggle-button').classList.contains('active')) {
		      deactivateFilterByPluginFilters();
		  } else {
		      activateFilterByPluginFilters();
		  }
	       };
	      const translationnPathSolverToggler = shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button');
	      translationnPathSolverToggler.onclick = (event) => {
	       	  deactivateFilterByPluginFilters();
		  if (shadow.querySelector('#mg-translation-graph-translation-path-solver-toggle-button').classList.contains('active')) {
		      hideTranslationPaths();
		  } else {
	       	      showTranslationPaths();
		  }
	      };
	      
              // Force Directed Graph Visualization
              const linkForce = () => {
		  linkAlpha = linkAlpha * (1-linkAlphaDecay);
		  nodeData.forEach(datum => {
                      const forwardNeighborIds = nodeForwardNeighbors[datum.id];
                      const neighborIds = (forwardNeighborIds.length > 0) ? forwardNeighborIds : Object.keys(nodeIdToProperties);
                      if (neighborIds.length > 0) {
			  const neighborMeanX = mean(neighborIds.map(neighborId => nodeIdToProperties[neighborId].x));
			  const neighborMeanY = mean(neighborIds.map(neighborId => nodeIdToProperties[neighborId].y));
			  const newX = datum.x * (1-linkAlpha) + linkAlpha * neighborMeanX;
			  const newY = datum.y * (1-linkAlpha) + linkAlpha * neighborMeanY;
			  datum.x = newX;
			  datum.y = newY;
                      }
		  });
              };
	      const render = () => {
	          nodeEnterSelection
		      .attr('cx', datum => datum.x)
		      .attr('cy', datum => datum.y);
	          edgeEnterSelection
		      .attr('d', datum => {
			  const offset = 30;
			  const source = nodeIdToProperties[datum.src];
			  const destination = nodeIdToProperties[datum.dst];
			  const midpointX = mean([source.x, destination.x]);
			  const midpointY = mean([source.y, destination.y]);
			  const dx = (destination.x - source.x);
			  const dy = (destination.y - source.y);
			  const normalization = Math.sqrt((dx * dx) + (dy * dy));
			  const offSetX = midpointX + offset*(dy/normalization);
			  const offSetY = midpointY - offset*(dx/normalization);
			  return `M ${source.x}, ${source.y} S ${offSetX}, ${offSetY} ${destination.x}, ${destination.y}`;
		      });
		  nodeTextEnterSelection
		      .attr('x', datum => datum.x)
		      .attr('y', datum => datum.y);
		  nodeTextBoundingBoxEnterSelection
		      .attr('x', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  const x = textElementBBox.x - nodeTextBoundingBoxPadding;
			  return x;
		      })
		      .attr('y', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  const y = textElementBBox.y - nodeTextBoundingBoxPadding;
			  return y;
		      })
                      .attr('width', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  return textElementBBox.width + 2 * nodeTextBoundingBoxPadding;
		      })
                      .attr('height', datum => {
			  const textElementId = concreteTypeNameToTextElementId(datum.id);
			  const textElementBBox = svg.select(`#${textElementId}`).node().getBBox();
			  return textElementBBox.height + 2 * nodeTextBoundingBoxPadding;
		      });
		  nodeTextEnterSelection.moveToFront();
	      };
              simulation
		  .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))
		  .force('collide', d3.forceCollide(paddingBetweenNodes).strength(0.25).iterations(200))
		  .force('links', linkForce)
		  .nodes(nodeData).on('tick', render)
		  .alphaMin(0.001)
		  .restart();
	      
              // Zooming
              const zoom = d3.zoom().on('zoom', () => {
		  zoomGroup
                      .attr('transform', d3.event.transform);
              });
              svg.call(zoom);

	      // Drag & Drop
	      drag.on('drag', datum => {
		  linkAlpha = initialLinkAlpha;
		  datum.x += d3.event.dx;
		  datum.y += d3.event.dy;
		  simulation
		      .alpha(0.1)
		      .restart();
		  render();
              });
	  });
	  
      };
      const updateTranslationGraph = (translationGraphData) => {
	  callAfterDOMUpdated(() => loadTranslationGraph(translationGraphData));
      }
      const requestTranslationGraphAbstractTypeUpdate = () => sendShadowWebsocketRequest({function: 'list_translators', kwargs: {source_type: abstractTypeDropdown.value}});
      abstractTypeDropdown.onchange = requestTranslationGraphAbstractTypeUpdate;

      /*****************/
      /* Type Explorer */
      /*****************/
      
      const updateTypeExplorer = (typeData) => {
	  const typeExplorerContentDiv = shadow.querySelector('#mg-type-explorer-content');
	  removeAllChildNodes(typeExplorerContentDiv);
	  typeExplorerContentDiv.classList.add('mg-explorer-tree-widget-container');
	  buildTreeWidget(typeExplorerContentDiv, typeData.result);
      }
      const requestTypeExplorerUpdate = () => sendShadowWebsocketRequest({function: 'list_types', kwargs: {}});
      
      /**********************/
      /* Algorithm Explorer */
      /**********************/
      
      const updateAlgorithmExplorer = (algorithmData) => {
	  const algorithmExplorerContentDiv = shadow.querySelector('#mg-algorithm-explorer-content');
	  removeAllChildNodes(algorithmExplorerContentDiv);
	  algorithmExplorerContentDiv.classList.add('mg-explorer-tree-widget-container');
	  buildTreeWidget(algorithmExplorerContentDiv, algorithmData.result);
      };
      
      /*************************/
      /* Algorithm Type Solver */
      /*************************/
      
      const updateAlgorithTypeSolverPlans = (planData) => {
	  const plansDiv = shadow.querySelector('#mg-algorithm-type-solver-plans');
	  plansDiv.classList.add('mg-explorer-tree-widget-container');
	  removeAllChildNodes(plansDiv);
	  if (objectSize(planData.result) == 0) {
	      const parargaphElement = document.createElement('p');
	      parargaphElement.innerHTML = 'Algorithm Unsatisfiable';
	      parargaphElement.classList.add('mg-algorithm-type-solver-unsatisfiable-algorithm-label');
	      plansDiv.append(parargaphElement);
	  } else {
	      buildTreeWidget(plansDiv, planData.result);
	  }
      };
      
      const updateAlgorithTypeSolverCurrentAlgorithmParameters = (algorithmParameterDataResponse) => {
	  const abstractAlgorithmPathDropdown = shadow.querySelector('#mg-algorithm-type-solver-abstract-algorithm-path-dropdown');
	  if (abstractAlgorithmPathDropdown.value === algorithmParameterDataResponse.input_kwargs.abstract_pathname) {
	      const abstractAlgorithmContentDiv = shadow.querySelector('#mg-algorithm-type-solver-abstract-algorithm-content');
	      removeAllChildNodes(abstractAlgorithmContentDiv);
	      const algorithmParameterData = algorithmParameterDataResponse.result;
	      const parameterData = algorithmParameterData.parameters;
	      const allParametersContainer = document.createElement('div');
	      allParametersContainer.setAttribute('id', 'mg-algorithm-type-solver-all-parameters-container');
	      abstractAlgorithmContentDiv.append(allParametersContainer);
	      Object.entries(parameterData).forEach(([parameterName, parameterProps]) => {
		  const parameterContainerDiv = document.createElement('div');
		  parameterContainerDiv.classList.add('mg-algorithm-type-solver-single-parameter-container');
		  allParametersContainer.append(parameterContainerDiv);
		  
		  const parameterNameElement = document.createElement('span');
		  parameterNameElement.classList.add('mg-algorithm-type-solver-parameter-name');
		  parameterNameElement.setAttribute('parameterName', parameterName);
		  parameterNameElement.innerHTML = parameterName + ':&nbsp;';
		  parameterContainerDiv.append(parameterNameElement);
		  
		  const parameterAbstractTypeElement = document.createElement('span');
		  parameterAbstractTypeElement.classList.add('mg-algorithm-type-solver-parameter-abstract-type');
		  parameterAbstractTypeElement.setAttribute('abstractType', parameterProps.type);
		  parameterAbstractTypeElement.innerHTML = parameterProps.type + '&nbsp;';
		  parameterContainerDiv.append(parameterAbstractTypeElement); 

		  const parameterConcreteTypeChoicesDropdown = document.createElement('select');
		  parameterConcreteTypeChoicesDropdown.classList.add('mg-algorithm-type-solver-parameter-concrete-type-dropdown');
		  parameterContainerDiv.append(parameterConcreteTypeChoicesDropdown);
		  parameterProps.choices.forEach(concreteTypeName => {
	       	      const optionElement = document.createElement('option');
	       	      optionElement.setAttribute('value', concreteTypeName);
	       	      optionElement.innerHTML = concreteTypeName;
	       	      parameterConcreteTypeChoicesDropdown.append(optionElement);
		  });
	      });
	      shadow.querySelectorAll('.mg-algorithm-type-solver-parameter-concrete-type-dropdown').forEach(dropdown => {
		  dropdown.onchange = (event) => {
		      const paramsDescription = {};
		      const parameterContainers = allParametersContainer.querySelectorAll('.mg-algorithm-type-solver-single-parameter-container');
		      parameterContainers.forEach(parameterContainer => {
			  const parameterName = parameterContainer.querySelector('.mg-algorithm-type-solver-parameter-name').getAttribute('parameterName');
			  const abstractTypeString = parameterContainer.querySelector('.mg-algorithm-type-solver-parameter-abstract-type').getAttribute('abstractType');
			  const concreteTypeString = parameterContainer.querySelector('.mg-algorithm-type-solver-parameter-concrete-type-dropdown').value;
			  paramsDescription[parameterName] = {abstract_type: abstractTypeString, concrete_type: concreteTypeString}
		      });
		      sendShadowWebsocketRequest({function: 'solve_algorithm', kwargs: {
			  abstract_pathname: abstractAlgorithmPathDropdown.value,
			  params_description: paramsDescription,
		      }});
		  }
	      });
	      shadow.querySelector('.mg-algorithm-type-solver-parameter-concrete-type-dropdown').onchange();
	  }
      }

      const aggregateAbstractAlgorithmPathNames = (data) => {
	  let result = [];
	  for (let key in data) {
	      if (data.hasOwnProperty(key)) {
		  const value = data[key]
		  if (data[key].hasOwnProperty('full_path')) {
		      result.push(data[key].full_path);
		  } else if (data[key].hasOwnProperty('children')) {
		      const recursiveResults = aggregateAbstractAlgorithmPathNames(data[key].children);
		      result = result.concat(recursiveResults);
		  }
	      }
	  }
	  return result;
      }
      
      const updateAlgorithTypeSolver = (algorithmData) => {
	  const algorithmTypeSolvlerContentDiv = shadow.querySelector('#mg-algorithm-type-solver-content');
	  removeAllChildNodes(algorithmTypeSolvlerContentDiv);
	  
	  const abstractAlgorithmPathDropdown = document.createElement('select');
	  abstractAlgorithmPathDropdown.setAttribute('id', 'mg-algorithm-type-solver-abstract-algorithm-path-dropdown');
	  algorithmTypeSolvlerContentDiv.append(abstractAlgorithmPathDropdown)
	  
	  const abstractAlgorithmContentDiv = document.createElement('div');
	  abstractAlgorithmContentDiv.setAttribute('id', 'mg-algorithm-type-solver-abstract-algorithm-content');
	  algorithmTypeSolvlerContentDiv.append(abstractAlgorithmContentDiv)
	  
	  const abstractAlgorithmPathNames = aggregateAbstractAlgorithmPathNames(algorithmData.result)
	  abstractAlgorithmPathNames.forEach(pathName => {
              const optionElement = document.createElement('option');
              optionElement.setAttribute('value', pathName);
              optionElement.innerHTML = pathName;
	      abstractAlgorithmPathDropdown.append(optionElement);
	  });
	  abstractAlgorithmPathDropdown.onchange = (event) => sendShadowWebsocketRequest({function: 'list_algorithm_params', kwargs: {abstract_pathname: abstractAlgorithmPathDropdown.value}});
	  abstractAlgorithmPathDropdown.onchange();
	  
	  const plansDiv = document.createElement('div');
	  plansDiv.setAttribute('id', 'mg-algorithm-type-solver-plans');
	  algorithmTypeSolvlerContentDiv.append(plansDiv);
      };
      
      /*******************/
      /* Plugin Explorer */
      /*******************/

      const pluginExplorerContentDiv = shadow.querySelector('#mg-plugin-explorer-content');
      removeAllChildNodes(pluginExplorerContentDiv);
      pluginExplorerContentDiv.classList.add('mg-explorer-tree-widget-container');
      buildTreeWidget(pluginExplorerContentDiv, pluginData);

      const requestAlgorithmListUpdate = () => sendShadowWebsocketRequest({function: 'list_algorithms', kwargs: {}});
      shadow.websocket.onopen = () => {
	  requestTranslationGraphAbstractTypeUpdate();
	  requestTypeExplorerUpdate();
	  requestAlgorithmListUpdate();
	  // TODO for the explorer tabs whose data we expect to not change, should we leave them here? Or eagerly determine it and pass it via RESOLVER_DATA? It should all be in the same place.
      }
      
  })({RESOLVER_DATA})
  
</script>
